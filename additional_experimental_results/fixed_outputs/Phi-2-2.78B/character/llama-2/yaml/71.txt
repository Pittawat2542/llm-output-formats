
"""
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
from datetime import date, time
from typing import Any

from dataclasses import asdict, dataclass, field

from pydantic.types import Json


class BaseModel(object):

    """This is a base class for all models in this project."""

    def __init__(self, **data: Any) -> None:
        """Initializes the model with data.

        Args:
            **data (Any): The data to initialize the model with.

        Returns:
            None:
                This method returns nothing.

        Raises:
            TypeError: If any of the provided arguments are not valid.
        """
        if not isinstance(data, dict):
            raise TypeError('"data" must be a dictionary.')

        for key in data:
            value = data[key]

            # Check if it's an int or float type.
            try:
                int(value)
                float(value)
            except ValueError:

                # Check if it's a str or bytes type.
                if isinstance(value, str):
                    value = value.encode('utf-8')
                elif not isinstance(value, bytes):

                    # Check if it's an int or float type.
                    try:
                        int(value)
                        float(value)
                    except ValueError:

                        # Otherwise it must be a date time type.
                        from datetime import datetime

                        if isinstance(value, (date, time)):
                            pass
                        else:
                            raise TypeError('"{}" should be one of the following types: "str", "int", '
                                            '"float", "datetime.date" or "datetime.time".'.format(key))

                # If we got to this point, it must be an instance of a subclass of Json and we can continue.
                try:
                    data[key] = json.loads(value)
                except TypeError as e:
                    raise TypeError('"{}" should be one of the following types: "str", "int", '
                                    '"float", "datetime.date" or "datetime.time".'.format(e))

        self._data = data

    def __str__(self):
        return str(json.loads(json.dumps(asdict(self))))

    def as_dict(self) -> dict:
        """Gets the data of this model in a dictionary format.

        Returns:
            A json formatted dictionary of all the data that is stored in this class instance.
        """
        return asdict(self)

    @classmethod
    def from_filepath(cls, path: str):
        """Initializes the model with the given file.

        Args:
            path (str): The local filesystem path to a json formatted file that contains the data for this class instance.

        Returns:
            A new instance of this model type containing the loaded data from the provided file.
        """

        with open(path, 'r') as fp:
            data = json.load(fp)

            return cls(**data)

    def save_to_filepath(self, path):
        """Saves this model to the given path in a file.

        Args:
            path (str): The local filesystem path of where to save this model's data in a json formatted file.
        """

        with open(path, 'w') as fp:
            json.dump(self._data, fp)


class UserModel(BaseModel):

    """This class models a user object and their details."""

    # The full name of this object in the database (e.g. `User`).
    _name = field(default='User')  # type: str

    # The user's login credentials (e.g. `username`, `password`) for authentication purposes.
    _login_info = field(default={}, alias="LoginInfo")  # type: Json = {}

    # A list of the users friends in this database session, or empty if this is a new user.
    _friends = field(default=[], alias="FriendsList")  # type: list[str] = []

    @property
    def name(self) -> str:
        """The name of this user object."""
        return self._name

    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise ValueError('"name" should be a string type.')
        self._name = value

    @property
    def login_info(self) -> Json:
        """The user's credentials for authentication purposes."""
        return self._login_info.copy() if self._login_info else {}

    @login_info.setter
    def login_info(self, value):
        if not isinstance(value, dict):
            raise ValueError('"login_info" should be a dictionary.')
        self._login_info = value

    @property
    def friends(self) -> list[str]:
        """A list of the users friends in this session or an empty list if it's new."""
        return self._friends.copy()

    @friends.setter
    def friends(self, value):
        if not isinstance(value, (list, tuple)):
            raise ValueError('"friends" should be a list type.')
        self._friends = [friend for friend in value]

    def add_friend(self, user: str) -> None:
        """Adds a new friend to this users friends list.

        Args:
            user (str): The name of the user whose data should be added to the users friend list.

        Returns:
            None: This method returns nothing.
        """
        self._friends.append(user)

    def remove_friend(self, user: str) -> None:
        """Removes a friend from this users friends list.

        Args:
            user (str): The name of the user whose data should be removed from the users friend list.

        Returns:
            None: This method returns nothing.
        """
        self._friends.remove(user)

    def is_friend_of(self, user: str) -> bool:
        """Checks whether a user is friends with this user.

        Args:
            user (str): The name of the user to check if they are friends with this user.

        Returns:
            bool: Whether or not `user` is one of users friends in this session.
        """
        return user in self._friends

    def has_login_info(self) -> bool:
        """Checks whether a users login info is set for authentication purposes.

        Returns:
            bool: Whether the user's login information is currently set or not.
        """
        return self._login_info != {}

    def get_login_info(self) -> Json:
        """Gets the users login info in a dict format for authentication purposes.

        Returns:
            Json: The users login info if it is set, or an empty dictionary if not.
        """
        if self._login_info != {}:
            return json.dumps(self._login_info)
        else:
            return {}

    def change_name(self, new_name: str) -> None:
        """Changes a users name in the database.

        Args:
            new_name (str): The name to set for this user.
        """
        self._data['name'] = new_name


class ItemModel(BaseModel):

    """This class models an item of data in a database."""

    # The name of the object in the database.
    _name = field(default='Item')

    # A dictionary containing all the information about this object's data.
    _data = field(default={})

    @property
    def name(self) -> str:
        """The name of the object that is being queried."""
        return self._name

    @name.setter
    def name(self, value: str):
        if not isinstance(value, str):
            raise ValueError('"name" should be a string type.')
        self._data['name'] = value

    def __str__(self):
        return str(json.loads(json.dumps(self._data)))

    def __repr__(self):
        return repr(self._data)


class ItemCollectionModel(BaseModel):

    """This class models a collection of items in the database."""

    # The name of this item collection as it is being queried.
    _name = field(default='Items')

    # A list of all the objects that are contained within this item collection.
    _objects: list[ItemModel] = []

    @property
    def objects(self) -> list[ItemModel]:
        """Returns a list with all the objects in this item collection."""
        return self._objects

    def add_object(self, object: ItemModel):
        """Adds an object to this items collection.

        Args:
            object (ItemModel): The item to add to this collections's items array.

        Returns:
            None: This method returns nothing.
        """
        if not isinstance(object, ItemModel):
            raise TypeError('"object" should be of type "ItemModel".')
        self._objects.append(object)

    def remove_object(self, object: str):
        """Removes an item from this collections's items array if it exists.

        Args:
            object (str): The name of the item to remove.

        Returns:
            None: This method returns nothing.
        """
        for i in range(len(self._objects) - 1, -1, -1):
            if self._objects[i].name == object:
                del self._objects[i]

    def has_object(self, name: str):
        """Checks whether or not a collection contains a specific item.

        Args:
            name (str): The name of the item to check for in this collections's items array.

        Returns:
            bool: Whether or not this collection contains a item with that name.
        """
        return any(item._data['name'] == name for item in self._objects)
