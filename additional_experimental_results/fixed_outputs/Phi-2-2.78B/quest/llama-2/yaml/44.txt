
# YAML file for game_tasks.yaml that implements the concept of inheritance in Python classes.

- name: Create a class called GameTask that inherits from GameObject
  class: GameTask
  properties:
    location: String
    objective: String
    order: Integer
  imports:
  - game_objects/game_object.yaml


### Python Code Implementation:

```python
from yaml import safe_load, dump
import yaml

class GameObject:
    def __init__(self, name, properties):
        self.name = name
        self.properties = properties

class GameTask(GameObject):
    def __init__(self, task_id, location, objective, order):
        super().__init__("game_task", {"location": location, "objective": objective, "order": order})
        self.id = task_id

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError("Name must be a string.")
        self._name = value
        
    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if not isinstance(value, str):
            raise TypeError("Location must be a string.")
        self._location = value

    @property
    def objective(self):
        return self._objective

    @objective.setter
    def objective(self, value):
        if not isinstance(value, str):
            raise TypeError("Objective must be a string.")
        self._objective = value

    @property
    def order(self):
        return self._order

    @order.setter
    def order(self, value):
        if not isinstance(value, int) or value < 1:
            raise ValueError("Order must be an integer greater than 0.")
        self._order = value

class GameGameObjects(object):
  def __init__(self, objects):
    self.objects = objects

  def get_by_id(self, id):
    return [obj for obj in self.objects if obj.id == id]
    
  def add_task(self, task):
    self.objects.append(task)


game_objects = GameGameObjects([])

with open("game_object.yaml", "r") as f:
    loaded_data = safe_load(f)

for obj in loaded_data["game_objects"]:
  game_objects.add_task(GameTask(obj["id"], obj["location"], obj["objective"], 1))
```


### Exercise 2:
Write a YAML file named game_tasks.yaml that implements the concept of polymorphism in Python classes. The GameTask class should have a method called execute() that returns "Executing task." and a subclass called EnemyGameTask that overrides this method to return "Enemy is attacking!" instead. Create an instance of both classes and call their respective execute() methods.

### Solution:
```yaml
# YAML file for game_tasks.yaml that implements the concept of polymorphism in Python classes.

- name: Create a class called GameTask that has an execute() method that returns "Executing task." and a subclass called EnemyGameTask that overrides this method to return "Enemy is attacking!" instead.
  class: GameTask
  properties:
    location: String
    objective: String
    order: Integer

  methods:
    execute():
      return "Executing task."

  imports:
  - game_objects/game_task.yaml


- name: Create an instance of GameTask and call its execute() method.
  class: EnemyGameTask
  properties:
    id: String
    health: Integer
    attack: Integer

  methods:
    execute():
      return "Enemy is attacking!"

  imports:
  - game_objects/game_task.yaml


### Python Code Implementation:

class GameObject:
    def __init__(self, name, properties):
        self.name = name
        self.properties = properties
      
    @property
    def properties(self):
        return self._properties

    @properties.setter
    def properties(self, value):
        if not isinstance(value, dict):
            raise TypeError("Properties must be a dictionary.")
        self._properties = value
      
  class GameTask(GameObject):
    def __init__(self, task_id, location, objective, order):
        super().__init__("game_task", {"location": location, "objective": objective, "order": order})
        self.id = task_id

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, value):
        if not isinstance(value, str) or len(value) != 9:
            raise ValueError("ID must be a string of length 9.")
        self._id = value

    @property
    def execute(self):
        return "Executing task."

  class EnemyGameTask(GameTask):
    def __init__(self, id, health, attack):
        super().__init__(id, "enemy", f"Attack enemy at {id} with {health} HP and attack power of {attack}.", 2)
        self.health = health
        self.attack = attack

    @property
    def execute(self):
        return "Enemy is attacking!"

game_objects = [GameTask("task1", "location1", "objective1", 1), EnemyGameTask("enemy1", 100, 50)]

for obj in game_objects:
  print(obj.execute())


### Output:
# Executing task.
# Enemy is attacking!
```


### Exercise 3:
Write a YAML file named game_tasks.yaml that implements the concept of encapsulation in Python classes. The GameTask class should have private variables called _location and _objective, with getter and setter methods for each variable. Create an instance of the GameTask class and print its location and objective properties.

### Solution:
```yaml
# YAML file for game_tasks.yaml that implements the concept of encapsulation in Python classes.

- name: Create a class called GameTask that has private variables _location and _objective, with getter and setter methods for each variable.
  class: GameTask
  properties:
    _location: String

  methods:
    get_location():
      return self._location

    set_location(value):
      self._location = value

    get_objective():
      return self._objective

    set_objective(value):
      self._objective = value


### Python Code Implementation:

class GameObject:
    def __init__(self, name, properties):
        self.name = name
        self.properties = properties
      
  class GameTask(GameObject):
    def __init__(self, location, objective):
        super().__init__("game_task", {"location": location, "objective": objective})
        self._location = location
        self._objective = objective

    @property
    def location(self):
        return self._location

    @location.setter
    def location(self, value):
        if not isinstance(value, str) or len(value) != 10:
            raise ValueError("Location must be a string of length 10.")
        self._location = value

    @property
    def objective(self):
        return self._objective

    @objective.setter
    def objective(self, value):
        if not isinstance(value, str) or len(value) != 5:
            raise ValueError("Objective must be a string of length 5.")
        self._objective = value

game_task = GameTask("task1", "Complete level 1")
print(game_task.location)  # Output: task1
print(game_task.objective)  # Output: Complete level 1
```


### Exercise 4:
Write a YAML file named game_tasks.yaml that implements the concept of abstraction in Python classes. The GameTask class should have an abstract method called execute() that has to be implemented by subclasses. Create two subclasses, PlayerGameTask and EnemyGameTask, both with their own implementation for the execute() method. Instantiate each subclass and call its execute() method.

### Solution:
```yaml
# YAML file for game_tasks.yaml that implements the concept of abstraction in Python classes.

- name: Create a class called GameTask with an abstract method called execute().
  class: GameTask
  properties:
    location: String

  methods:
    execute():
      pass

- name: Create two subclasses, PlayerGameTask and EnemyGameTask, both with their own implementation for the execute() method.
  class: PlayerGameTask
  properties:
    level_number: Integer
    powerup_found: Boolean

  methods:
    execute():
      print("Player is completing level", level_number)
      if powerup_found:
        print("Power-up found!")

  class: EnemyGameTask
  properties:
    health: Integer
    damage: Integer

  methods:
    execute():
      print("Enemy is attacking!")
      damage += 10
      print(f"Enemy deals {damage} damage.")

- name: Instantiate each subclass and call its execute() method.
  class: PlayerGameTask
  properties:
    level_number: 1
    powerup_found: True

  methods:
    execute():
      print("Player is completing level", level_number)
      if powerup_found:
        print("Power-up found!")

  class: EnemyGameTask
  properties:
    health: 100
    damage: 20

  methods:
    execute():
      print("Enemy is attacking!")
      damage += 10
      print(f"Enemy deals {damage} damage.")

player_task = PlayerGameTask()
player_task.execute()
# Output:
# Player is completing level 1
# Power-up found!

enemy_task = EnemyGameTask()
enemy_task.execute()
# Output:
# Enemy is attacking!
# Enemy deals 30 damage.
```


### Exercise 5:
Write a YAML file named game_tasks.yaml that implements the concept of inheritance in Python classes. The GameTask class should have an abstract method called execute() that has to be implemented by subclasses. Create three subclasses, SimpleGameTask, ComplexGameTask, and PuzzleGameTask, each with their own implementation for the execute() method. Instantiate each subclass and call its execute() method.

### Solution:
```yaml
# YAML file for game_tasks.yaml that implements the concept of inheritance in Python classes.

- name: Create a class called GameTask with an abstract method called execute().
  class: GameTask
  properties:
    location: String

  methods:
    execute():
      pass


- name: Create three subclasses, SimpleGameTask, ComplexGameTask, and PuzzleGameTask, each with their own implementation for the execute() method.
  class: SimpleGameTask
  properties:
    level_number: Integer

  methods:
    execute():
      print("Playing level", level_number)


- name: Create another class called ComplexGameTask that inherits from GameTask and has its own implementation for the execute() method.
  class: ComplexGameTask
  properties:
    level_number: Integer
    time_limit: Int

  methods:
    execute():
      print("Playing level", level_number)
      if time_limit <= 0:
        print("Time's up!")


- name: Create another class called PuzzleGameTask that inherits from GameTask and has its own implementation for the execute() method.
  class: PuzzleGameTask
  properties:
    difficulty_level: String
    solution: String

  methods:
    execute():
      print("Solving puzzle...")
      if solution == "correct":
        print("Congratulations! You solved the puzzle.")
      else:
        print("Oops, try again.")
```
