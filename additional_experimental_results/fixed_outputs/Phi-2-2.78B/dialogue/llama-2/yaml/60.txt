Game: {
  "version": "1.0",
  "name": "Game",
  "players": {},
  "dialogues": [],
  "actions": []
}
"""
import abc
import inspect
from typing import Any, Dict, List, Tuple


class Game(object):

    def __init__(self) -> None:
        super().__init__()


class BaseGame(Game):
    """A game that has a dialogues section and an action section."""

    @abc.abstractmethod
    def add_action(self, text: str) -> None:
        raise NotImplementedError("Abstract method")

    @abc.abstractmethod
    def add_dialogue(self, speaker: str, text: str) -> None:
        raise NotImplementedError("Abstract method")

    @property
    @abc.abstractmethod
    def dialogues(self) -> List[str]:
        """A list of the games dialogues."""
        raise NotImplementedError("Abstract property")

    def __repr__(self):
        return "<Game %s>%r" % (type(self).__name__, self.dialogues)


class FixedGame(BaseGame):
    """A game with fixed dialogues."""

    @property
    def dialogues(self) -> List[str]:
        return [
            'Hello world!',
            'How are you?',
            'Goodbye world!'
        ]


class GameReprMixin(object):

    def __repr__(self):
        rep = super().__repr__()
        attrs = self.get_attrs()
        if attrs:
            attrs_str = ", ".join([f"{a}={getattr(self, a)}" for a in attrs])
            rep += f", attrs={attrs_str}"
        return rep

    def get_attrs(self):
        """Returns a list of attributes to include in the representation.

        By default returns all non-abstract (non-private) attributes.
        You can also override this method if you want to return only specific
        attributes.
        """
        return [a for a, b in inspect.getmembers(self)
                if not isinstance(b, abc.ABCMeta)]

    def get_attr_values(self):
        """Returns a dictionary of all attribute values."""
        return {name: value
                for name, value in self.__dict__.items()}


class ActionGame(BaseGame, GameReprMixin):

    @property
    def dialogues(self) -> List[str]:
        return [
            'Hello world!',
            'How are you?',
            'Goodbye world!'
        ]

    def add_action(self, text: str) -> None:
        """Adds an action to the game."""
        if not text.startswith("ACTION:"):
            raise ValueError("Action must start with ACTION:")
        text = text[len("ACTION:"):].strip()
        # Add a check here if you want to validate that the input is a valid
        # action or throw an exception.
        super().add_dialogue(None, None, text)

    def add_dialogue(self, speaker: str, text: str) -> None:
        """Adds a dialogue in the game."""
        if not self._can_add_dialogue(speaker):
            raise ValueError("Invalid speaker")

        super().add_action(text)

    def _can_add_dialogue(self, speaker: str) -> bool:
        return speaker is None or (
                isinstance(speaker, str) and
                speaker in self.get_attrs())


class DialoguesGame(BaseGame, GameReprMixin):

    @property
    def dialogues(self) -> List[str]:
        return [
            'Hello world!',
            'How are you?',
            'Goodbye world!'
        ]

    def add_dialogue(self, speaker: str, text: str) -> None:
        """Adds a dialogue in the game."""
        if not self._can_add_dialogue(speaker):
            raise ValueError("Invalid speaker")

        super().add_action(None, None, text)

    def _can_add_dialogue(self, speaker: str) -> bool:
        return speaker is None or (
                isinstance(speaker, str) and
                speaker in self.get_attrs())
